/* ========================================
 *
 * Copyright YOUR COMPANY, THE YEAR
 * All Rights Reserved
 * UNPUBLISHED, LICENSED SOFTWARE.
 *
 * CONFIDENTIAL AND PROPRIETARY INFORMATION
 * WHICH IS THE PROPERTY OF your company.
 *
 * ========================================
 */

#include <stdbool.h>
#include <stdio.h>
#include <string.h>

// FreeRTOS
#include "FreeRTOS.h"
//
#include "FreeRTOS_time.h"
#include "task.h"

// Pico
#include "hardware/rtc.h"
#include "pico/error.h"
#include "pico/stdio.h"
#include "pico/stdlib.h"
#include "pico/util/datetime.h"

//
#include "CLI-commands.h"
#include "File-related-CLI-commands.h"
#include "FreeRTOS_CLI.h"
#include "crash.h"
#include "filesystem_test_suite.h"
#include "stdio_cli.h"

/*
 * Register commands that can be used with FreeRTOS+CLI.
 * The commands are defined in CLI-commands.c and
 * File-related-CLI-commands.c respectively.
 */
// extern void vRegisterFileSystemCLICommands(void);

// stdioTask - the function which handles input from the UART
// Note:
//   This initially used Task Notifications,
//   but that caused a conflict with filesystem calls that also use
//   Task Notifications.
static void stdioTask(void *arg) {
    (void)arg;

    size_t cInputIndex = 0;
    static char cOutputString[cmdMAX_OUTPUT_SIZE] = {0};
    static char cInputString[cmdMAX_INPUT_SIZE] = {0};
    BaseType_t xMoreDataToFollow = 0;
    bool in_overflow = false;

    for (;;) {
        int cRxedChar = getchar_timeout_us(1000 * 1000);
        /* Get the character from terminal */
        if (PICO_ERROR_TIMEOUT == cRxedChar) {
            continue;
        }
        printf("%c", cRxedChar);  // echo
        stdio_flush();

        static bool first = true;
        if (first) {
            printf("\033[2J\033[H");  // Clear Screen

            // Check fault capture from RAM:
            crash_info_t const *const pCrashInfo = crash_handler_get_info();
            if (pCrashInfo) {
                printf("*** Fault Capture Analysis (RAM): ***\n");
                int n = 0;
                do {
                    char buf[256] = {0};
                    n = dump_crash_info(pCrashInfo, n, buf, sizeof(buf));
                    if (buf[0]) printf("\t%s", buf);
                } while (n != 0);
            }

            // void datetime_to_str (char *buf, uint buf_size, const datetime_t
            // *t
            datetime_t t = {0, 0, 0, 0, 0, 0, 0};
            char datetime_buf[256] = {0};
            rtc_get_datetime(&t);
            datetime_to_str(datetime_buf, sizeof(datetime_buf), &t);
            printf("\r%s ", datetime_buf);
            printf("\nFreeRTOS+CLI> ");
            stdio_flush();

            first = false;
        }

        /* Newline characters are taken as the end of the command
         string. */
        if (cRxedChar == '\n' || cRxedChar == '\r') {
            in_overflow = false;

            TickType_t xStart = 0;
            /* Just to space the output from the input. */
            printf("%c", '\n');
            stdio_flush();

            if (!strnlen(cInputString,
                         sizeof cInputString)) {  // Empty input
                printf("%s", pcEndOfOutputMessage);
                continue;
            }
            const char timestr[] = "time ";
            if (0 == strncmp(cInputString, timestr, 5)) {
                xStart = xTaskGetTickCount();
                char tmp[cmdMAX_INPUT_SIZE] = {0};
                strlcpy(tmp, cInputString + 5, sizeof tmp);
                strlcpy(cInputString, tmp, cmdMAX_INPUT_SIZE);
            }
            /* Process the input string received prior to the
             newline. */
            do {
                /* Pass the string to FreeRTOS+CLI. */
                cOutputString[0] = 0x00;
                xMoreDataToFollow = FreeRTOS_CLIProcessCommand(
                    cInputString, cOutputString, cmdMAX_OUTPUT_SIZE);

                /* Send the output generated by the command's
                 implementation. */
                printf("%s", cOutputString);

                /* Until the command does not generate any more output.
                 */
            } while (xMoreDataToFollow);

            if (xStart) {
                printf("Time: %lu s\n",
                       (unsigned long)(xTaskGetTickCount() - xStart) /
                           configTICK_RATE_HZ);
            }
            /* All the strings generated by the command processing
             have been sent.  Clear the input string ready to receive
             the next command.  */
            cInputIndex = 0;
            memset(cInputString, 0x00, cmdMAX_INPUT_SIZE);

            /* Transmit a spacer to make the console easier to
             read. */
            printf("%s", pcEndOfOutputMessage);
            fflush(stdout);

        } else {  // Not newline

            if (in_overflow) continue;

            if ((cRxedChar == '\b') || (cRxedChar == cmdASCII_DEL)) {
                /* Backspace was pressed.  Erase the last character
                 in the string - if any. */
                if (cInputIndex > 0) {
                    cInputIndex--;
                    cInputString[(int)cInputIndex] = '\0';
                }
            } else {
                /* A character was entered.  Add it to the string
                 entered so far.  When a \n is entered the complete
                 string will be passed to the command interpreter. */
                if (cInputIndex < cmdMAX_INPUT_SIZE - 1) {
                    cInputString[(int)cInputIndex] = cRxedChar;
                    cInputIndex++;
                } else {
                    printf("\a[Input overflow!]\n");
                    fflush(stdout);
                    memset(cInputString, 0, sizeof(cInputString));
                    cInputIndex = 0;
                    in_overflow = true;
                }
            }
        }
    }
}
/* Start UART operation. */
void CLI_Start() {
    vRegisterCLICommands();
    vRegisterMyCLICommands();
    register_fs_tests();
    vRegisterFileSystemCLICommands();

    stdio_init_all();
    FreeRTOS_time_init();

    static StackType_t xStack[1024];
    static StaticTask_t xTaskBuffer;
    TaskHandle_t th = xTaskCreateStatic(
        stdioTask, "stdio Task", sizeof xStack / sizeof xStack[0], 0,
        tskIDLE_PRIORITY + 2, /* Priority at which the task is created. */
        xStack, &xTaskBuffer);
    configASSERT(th);
}

/* [] END OF FILE */
